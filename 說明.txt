
 luapp
=======

簡介:
    luapp 是建立在 lua 之上的工具
    將 lua 的 C 語言介面給包裝起來
    提供一個容易讓 C++ 使用的介面
    luapp 只有用標頭檔實作所以不需要另外編譯建立 library


版本號進號規則:
    進號規則遵守 Semantic Versioning 2.0.0
    A.B.C
    A: 當使用介面功能有修改或刪除才會進號，所以只要這個數字沒變就保證了向下相容性
    B: 當A不需進號，但是有新增介面時，此欄位就會進號
    C: 介面沒有變動，只有修正bug或者提升效能


luapp 主要的功能有這些:
    .協助把 C++ 的類別植入 lua 當中，之後便可在 lua 裡建立 C++ 物件了
    .C++ 的成員函式可以綁上物件指標傳給 lua 當成全域函式呼叫
    .C++ 可以呼叫 lua 的全域函式
    .幾種 luapp 指定的通用資料型態可以在 lua 跟 C++ 之間交流傳遞
    .支援將 lua 程式碼內嵌在 C++ 程式碼當中
    .table 結構可以在 C++ 跟 lua 之間交流傳遞，但是不支援的元素型態會被忽略
    .協助建立 lua 模組(在模組狀態下可支援的 luapp 介面會少很多，這部份還有待實作)
    .實作 lua::Var 這樣的通用容器，可裝多種資料型態


該注意的陷阱:
    .lua 無法得知 C++ 物件的真實記憶體大小
        在 lua 這邊建立的 C++ 物件是由 table 加上 user data 模擬的
        雖然在 user data 被清除的時候會去釋放 C++ 物件
        但是對 lua 而言這 user data 只佔了一個指標的記憶體空間
        所以 lua 的垃圾回收機制無法查覺到廢棄 C++ 物件已經佔用太多空間
        你可以等 lua 自己的周期性清理工作來處理
        或者自己定期執行 collectgarbage("collect") 來解決這個隱憂

    .lua 裡的 C++ 物件禁止修改 index 0
        C++ 物件在 lua 裡是以 table 模擬而成的存在
        這個 table 的 index 0 是禁用的
        例如這種錯誤 local t = NewObject(); t[0] = 10;
        index 0 在 luapp 實作裡被用來儲存真正的物件指標
        (當然了，你可以修改程式碼來改用其他值來取代0，例如像 100000 這種很少會用到的 index)

    .C++ 物件在 lua 裡面並非生命週期結束就解構，釋放時機是由 lua 決定的
    .目前導入 lua 的類別只能使用無參數的建構子，以後可能會實作多參數的版本
    .傳入 lua 的空指標不會轉成 nil，因為我認為兩者還是需要做區分，檢查空指標是 C++ 的責任
    .lua::Table 使用等號運算子時會複製整個結構，不像 lua table 是複製參考
    .要讓 lua 模組正常運作，lua 不能編譯成靜態函式庫


以下為 luapp 跟 lua 通用的資料型態:
    lua::Int     整數
    lua::Num     浮點數，lua 預設是使用倍精數
    lua::Str     字串，用 std::string 實作
    lua::Bool    只有 true 跟 false 兩種值的型態
    lua::Table   用法大致跟 lua table 一樣，但是等號運算子會真的複製整個容器
    lua::Nil     這跟 lua 的 nil 是一樣的角色定位
    lua::Ptr     一個不定型的指標，傳進 lua 會以 light user data 的身份來儲存


以下三個為 luapp 不支援的 lua 資料型態:
    function     還沒決定如何實作
    thread       這個是 lua 內部功能，也許以後會支援，但是 C++ 這邊頂多只能代為保管
    user data    個人覺得 lua::Ptr 使用上更加直覺、簡單，所以不去支援這項
